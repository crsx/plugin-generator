/*
* generated by Xtext
*/
package ${package}.ui.outline;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;

import ${package}.Utils;
import ${package}.Utils.CrsxTermType;
import ${package}.crsx.Declaration;
import ${package}.crsx.EmbeddedText;
import ${package}.crsx.Term;
<#if embeddedGrammars??>
    <#list embeddedGrammars as embeddedGrammar>
        <#list embeddedGrammar.exportedNonTerminals as exportedNonterminal>
import ${package}.crsx.Embedded${embeddedGrammar.name?upper_case}${exportedNonterminal.name};
        </#list>
        <#list embeddedGrammar.outlineElements as outlineElement>
import ${package}.crsx.${outlineElement.classname};
        </#list>
    </#list>
</#if>

/**
 * customization of the default outline structure
 * 
 */
public class CrsxOutlineTreeProvider extends DefaultOutlineTreeProvider {
    
    boolean grouping = false;
    
    Map<String,IOutlineNode> functionSortMap;
    
    public CrsxOutlineTreeProvider(){
        functionSortMap = new HashMap<String,IOutlineNode>();
    }
    
    /**
     * Rules of the same function sort will be grouped under function sort node
     * if set to true
     * 
     * @param value
     */
    public void setGrouping(boolean value){
        this.grouping = value;
    }
    
    /**
     * @see #setGrouping(boolean)
     * 
     * @return
     */
    public boolean getGrouping(){
        return grouping;
    }
    
    /**
     * Creates outline node for declaration
     * 
     * If the declaration is just a term, declaration node is skipped in
     * outline view and node for term is included
     * 
     * @param parentNode Outline view parent node
     * @param declaration ecore model declaration node
     */
    protected void _createNode(IOutlineNode parentNode, Declaration declaration) {
        
        Utils.CrsxDeclarationType declType = Utils.determineDeclarationType(declaration);
        IOutlineNode effectiveParentNode = parentNode;
        String functionSortName = null;
        
        if( declType == Utils.CrsxDeclarationType.TERM ||
                declType == Utils.CrsxDeclarationType.GROUP ){
            
            createNodeDispatcher.invoke(parentNode,declaration.getOptionOrTerm());
            return;
            
        }else if(grouping && (declType == Utils.CrsxDeclarationType.RULE)){
            
            functionSortName = Utils.ruleFunctionSortName(declaration);
            effectiveParentNode = functionSortMap.get(functionSortName);
            
        }else if(grouping && (declType == Utils.CrsxDeclarationType.NAMED_RULE)){
            functionSortName = Utils.namedRuleFunctionSortName(declaration);
            effectiveParentNode = functionSortMap.get(functionSortName);
        }
        
        if(effectiveParentNode == null){
            Image image = imageDispatcher.invoke(declaration);
            String label = String.format("%s[...]:: ?", functionSortName);
            effectiveParentNode = createEObjectNode(parentNode, declaration, image, label, false);
            functionSortMap.put(functionSortName, effectiveParentNode);
        }
            
        Object text = textDispatcher.invoke(declaration);
        boolean isLeaf = isLeafDispatcher.invoke(declaration);
        if (text == null && isLeaf)
            return;
        Image image = imageDispatcher.invoke(declaration);
        IOutlineNode node = createEObjectNode(effectiveParentNode, declaration, image, text, isLeaf);
        
        if( grouping && (declType == Utils.CrsxDeclarationType.FUNCTION_SORT
                || declType == Utils.CrsxDeclarationType.POLYMORPHIC_FUNCTION_SORT)){
            functionSortName = Utils.functionSortName(declaration);
            functionSortMap.put(functionSortName, node);
        }
    }
    
    /**
     * Create document root children
     * 
     * If root of the document is declaration group (namespace), skip creation of
     * declaration node
     * 
     * @param parentNode
     * @param declaration
     */
    protected void _createChildren(DocumentRootNode parentNode, Declaration declaration) {
        functionSortMap.clear();
        Utils.CrsxDeclarationType declType = Utils.determineDeclarationType(declaration);
        if( declType == Utils.CrsxDeclarationType.TERM ||
                declType == Utils.CrsxDeclarationType.GROUP ){
            createNodeDispatcher.invoke(parentNode,declaration.getOptionOrTerm());
        }else{
            createNode(parentNode, declaration);
        }
    }
    
    protected void _createChildren(IOutlineNode parentNode, Declaration declaration) {
        Utils.CrsxDeclarationType declType = Utils.determineDeclarationType(declaration);
        if( declType == Utils.CrsxDeclarationType.RULE ||
                declType == Utils.CrsxDeclarationType.NAMED_RULE ){
                
                Term right = declaration.getRight();
                CrsxTermType termType = Utils.determineTermType(right);
                if(termType == CrsxTermType.EMBEDDED_TERM){
                    createNode(parentNode,right.getEmbded());
                    return;
                }
        }
        
        for (EObject childElement : declaration.eContents())
            createNode(parentNode, childElement);
    }

    
    /**
     * Creates outline node for term
     * 
     * If the term is just list of terms, it is ommitted and children are directly 
     * added to the parent term
     * 
     * @param parentNode
     * @param term
     */
    protected void _createNode(IOutlineNode parentNode, Term term) {
        if (!term.getTerms().isEmpty()){
            for(Declaration decl : term.getTerms()){
                createNode(parentNode,decl);
            }
        }else{
            Object text = textDispatcher.invoke(term);
            boolean isLeaf = isLeafDispatcher.invoke(term);
            if (text == null && isLeaf)
                return;
            Image image = imageDispatcher.invoke(term);
            createEObjectNode(parentNode, term, image, text, isLeaf);
        }
    }

    /**
     * Determines if declaration node is leaf in outline view
     * 
     * If declaration is function sort or rule, it's children are
     * not included in the outline view, otherwise they are
     * 
     * @param declaration
     * @return
     */
    protected boolean _isLeaf(final Declaration declaration) {
        Utils.CrsxDeclarationType declType = Utils.determineDeclarationType(declaration);
        switch (declType){
        case FUNCTION_SORT:
        case POLYMORPHIC_FUNCTION_SORT:
        case DATA_SORT:
        case POLYMORPHIC_DATA_SORT:
            return true;
        case NAMED_RULE:
        case RULE:
            {
                Term right = declaration.getRight();
                return Utils.determineTermType(right) != CrsxTermType.EMBEDDED_TERM;
            }
        default:
            return false;   
        }
    }
    
    protected boolean _isLeaf(final EmbeddedText embedded) {
        return true;
    }

    
    /**
     * Determines whether term should be a leaf in outline view
     * 
     * @param term
     * @return
     */
    protected boolean _isLeaf(final Term term) {
        Utils.CrsxTermType termType = Utils.determineTermType(term);
        switch(termType){
            case DIRECTIVE_USE:
            case DIRECTIVE_ADD_GRAMMAR:
            case DIRECTIVE_LAX:
            case DIRECTIVE_OTHER:
                return true;
            default:
                return false;
        }
    }
    
<#if embeddedGrammars??>
    // Generated methods for embedded languages
    <#list embeddedGrammars as embeddedGrammar>
        <#list embeddedGrammar.outlineElements as outlineElement>
<#if outlineElement.leaf>
    protected boolean _isLeaf(${outlineElement.classname} element){
        return true;
    }

</#if>
<#if outlineElement.hidden>
    protected void _createNode(IOutlineNode parentNode, ${outlineElement.classname} element) {
        createChildren(parentNode,element);
    }

</#if>
        </#list>

<#list embeddedGrammar.exportedNonTerminals as exportedNonterminal>
    protected void _createNode(IOutlineNode parentNode, Embedded${embeddedGrammar.name?upper_case}${exportedNonterminal.name} element) {
        createChildren(parentNode,element);
    }
    
    protected boolean _isLeaf(Embedded${embeddedGrammar.name?upper_case}${exportedNonterminal.name} element){
        return false;
    }
</#list>
    </#list>
</#if>
}
